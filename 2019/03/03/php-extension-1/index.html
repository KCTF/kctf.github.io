<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>初探php拓展层面 | kn0ck&#39;s blog | 一群CTF爱好者</title>

  
  <meta name="author" content="kn0ck Team">
  

  
  <meta name="description" content="kn0ck战队成立于2017年9月，是由一群来自全国各地的网络爱好者组成，战队成员因兴趣与热爱而聚集，以不服输的精神全力向着梦想进发。作为一支新兴CTF队伍，战队的宗旨是通过实际比赛将理论知识更好的发挥，以赛代练，锻炼和提升个人的技术水平，在比赛中广交朋友，共同进步。">
  

  
  <meta name="keywords" content="CTF,kn0ck,网络安全,web,pwn,夺旗赛">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="初探php拓展层面">

  <meta property="og:site_name" content="kn0ck&#39;s blog">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="kn0ck&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">kn0ck&#39;s blog</a>
    </h1>
    <p class="site-description">一群CTF爱好者</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/author">队员</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>初探php拓展层面</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/03/php-extension-1/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-03T13:27:55.000Z">
          2019-03-03
        </time>
      </a>
    </span>
    
    <span class="posted-on">
      <a href="/2019/03/03/php-extension-1/" rel="bookmark">
        
          p0desta
        

      </a>
    </span>
    
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>本文首发先知社区，文章链接：<a href="https://xz.aliyun.com/t/4214" target="_blank" rel="noopener">https://xz.aliyun.com/t/4214</a></p>
</blockquote>
<p>前段时间想写一个静态代码审计工具,需要对php扩展熟悉一些,那么自己从零开始接触这一块,如果有错误的地方,麻烦师傅们指正。</p>
<p>另外呢网上虽然有一些文章,但是感觉都不是特别细,对于刚入门的我来说有些难以理解,因此详细的记录下自己的学习过程。</p>
<a id="more"></a>

<p>我在mac环境上折腾了两天gdb,还是没折腾好,无奈选择docker,这里推荐一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/hxer/php-debug/blob/master/Dockerfile</span><br></pre></td></tr></table></figure>

<p>这个dockerfile的vld和php版本不匹配,需要更换下低版本的vld。</p>
<p>启动命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -d --security-opt seccomp=unconfined -v /Users/p0desta/Desktop/code:/home php5-debug</span><br></pre></td></tr></table></figure>

<h4 id="编写最简单的php扩展"><a href="#编写最简单的php扩展" class="headerlink" title="编写最简单的php扩展"></a>编写最简单的php扩展</h4><ul>
<li><p>在ext目录下执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ext_skel --extname=p0desta</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后进入到扩展目录下,编辑config.m4文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16 dnl PHP_ARG_ENABLE(foobar, whether to enable foobar support,</span><br><span class="line">17 dnl Make sure that the comment is aligned:</span><br><span class="line">18 dnl [  --enable-foobar           Enable foobar support])</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除第16-18行的注释</p>
</li>
<li><p>然后去php_p0desta.h文件,添加函数声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(confirm_foobar_compiled);</span><br><span class="line">PHP_FUNCTION(p0desta);</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后到p0desta.c中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const zend_function_entry p0desta_functions[] = &#123;</span><br><span class="line">	PHP_FE(p0desta, NULL)</span><br><span class="line">	PHP_FE(confirm_p0desta_compiled,	NULL)		/* For testing, remove later. */</span><br><span class="line">	PHP_FE_END	/* Must be the last line in p0desta_functions[] */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加如下<code>PHP_FE(p0desta, NULL)</code></p>
</li>
<li><p>然后到最底下编写函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(p0desta)</span><br><span class="line">&#123;</span><br><span class="line">	php_printf(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在当前目录下执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">phpize</span><br><span class="line">./configure --enable-p0desta --enable-debug</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>然后会在modules文件夹下生存<code>so</code>文件,在php.ini中添加拓展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension=p0desta.so</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/228577/1557153079741-4c7090fd-cd68-4345-b79b-6494ee37879a.png#align=left&display=inline&height=430&originHeight=430&originWidth=720&size=0&status=done&width=720" alt></p>
<p>然后就可以调用自写的函数。</p>
<h4 id="php代码的大致执行流程"><a href="#php代码的大致执行流程" class="headerlink" title="php代码的大致执行流程"></a>php代码的大致执行流程</h4><p>开始 -&gt; Scanning,将php代码转换为语言片段(Tokens) -&gt; Parsing,将tokens转化为简单而有意义的表达式 -&gt; Compilation,将表达式编译成opcode -&gt; Execution,顺次执行opcodes,从而实现php脚本的功能。</p>
<h4 id="hook最简单的opcode"><a href="#hook最简单的opcode" class="headerlink" title="hook最简单的opcode"></a>hook最简单的opcode</h4><p>关于一些宏的解释参考:<code>https://github.com/pangudashu/php7-internal/blob/master/7/hook.md</code></p>
<p>这里我使用<code>zend_set_user_opcode_handler</code>函数来hook <code>echo</code>函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_set_user_opcode_handler(ZEND_ECHO, ppecho);</span><br></pre></td></tr></table></figure>

<p>主要原理是将对应的Zend op的handler函数替换成我们自己定义的来实现HOOK</p>
<p>首先我在扩展.h中定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_OPCODE_HANDLER_ARGS void</span></span><br><span class="line">PHP_FUNCTION(confirm_foobar_compiled);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ppecho</span><span class="params">(ZEND_OPCODE_HANDLER_ARGS)</span></span>;</span><br></pre></td></tr></table></figure>

<p>扩展.c中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINIT_FUNCTION(p_echo)</span><br><span class="line">&#123;</span><br><span class="line">	/* If you have INI entries, uncomment these lines</span><br><span class="line">	REGISTER_INI_ENTRIES();</span><br><span class="line">	*/</span><br><span class="line">	zend_set_user_opcode_handler(ZEND_ECHO, ppecho);</span><br><span class="line">	return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ppecho(ZEND_OPCODE_HANDLER_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">	php_printf(&quot;hook success&quot;);</span><br><span class="line">	return ZEND_USER_OPCODE_RETURN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果打算放行继续执行的话<code>return ZEND_USER_OPCODE_DISPATCH</code>,如果不继续执行的话<code>return ZEND_USER_OPCODE_RETURN</code></p>
<p>编译完之后看一下效果</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/228577/1557153079547-3db86644-1931-473b-a9ac-a49e54bad890.png#align=left&display=inline&height=400&originHeight=400&originWidth=1056&size=0&status=done&width=1056" alt></p>
<h4 id="Webshell简单防御初探"><a href="#Webshell简单防御初探" class="headerlink" title="Webshell简单防御初探"></a>Webshell简单防御初探</h4><p>关于一些PHP内核中的定义详情请参考<code>https://www.kancloud.cn/kancloud/php-internals/42755</code></p>
<p>这里我们暂时需要了解的有</p>
<ul>
<li><p>全局变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EG()、这个宏可以用来访问符号表，函数，资源信息和常量</span><br><span class="line">CG() 用来访问核心全局变量</span><br><span class="line">PG() PHP全局变量。我们知道php.ini会映射一个或者多个PHP全局结构。举几个使用这个宏的例子：PG(register_globals), PG(safe_mode), PG(memory_limit)</span><br><span class="line">FG() 文件全局变量。大多数文件I/O或相关的全局变量的数据流都塞进标准扩展出口结构。</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数类型<br>Zend引擎将函数分为以下几个类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define ZEND_INTERNAL_FUNCTION 1</span><br><span class="line">#define ZEND_USER_FUNCTION 2 </span><br><span class="line">#define ZEND_OVERLOADED_FUNCTION 3</span><br><span class="line">#define ZEND_EVAL_CODE 4</span><br><span class="line">#define ZEND_OVERLOADED_FUNCTION_TEMPORARY 5</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ZEND_USER_FUNCTION （用户函数:用户定义的函数）</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ZEND_INTERNAL_FUNCTION (内部函数:由扩展、PHP内核、Zend引擎提供的内部函数)</p>
</li>
<li><p>变量函数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$func = <span class="string">'print_r'</span>;</span><br><span class="line">$func(<span class="string">'i am print_r function.'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名函数</p>
</li>
</ul>
</li>
<li><p>php7的_zend_execute_data</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_execute_data</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> zend_op       *opline;           <span class="comment">/* executed opline                */</span></span><br><span class="line">	zend_execute_data   *call;             <span class="comment">/* current call                   */</span></span><br><span class="line">	zval                *return_value;</span><br><span class="line">	zend_function       *func;             <span class="comment">/* executed function              */</span></span><br><span class="line">	zval                 This;             <span class="comment">/* this + call_info + num_args    */</span></span><br><span class="line">	zend_execute_data   *prev_execute_data;</span><br><span class="line">	zend_array          *symbol_table;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ZEND_EX_USE_RUN_TIME_CACHE</span></span><br><span class="line">	<span class="keyword">void</span>               **run_time_cache;   <span class="comment">/* cache op_array-&gt;run_time_cache */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ZEND_EX_USE_LITERALS</span></span><br><span class="line">	zval                *literals;         <span class="comment">/* cache op_array-&gt;literals       */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>我们看一下如下代码的opcode</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">eval</span>(<span class="string">"system('whoami');"</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/228577/1557153079571-a4ab6121-bf21-4d74-9c35-f37c9ed57a11.png#align=left&display=inline&height=1618&originHeight=1618&originWidth=2736&size=0&status=done&width=2736" alt></p>
<p>我们hook掉<code>INCLUDE_OR_EVAL</code></p>
<p>修改<code>php_hook_eval.h</code>增加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(confirm_foobar_compiled);</span><br><span class="line">static int HOOK_INCLUDE_OR_EVAL(ZEND_OPCODE_HANDLER_ARGS);</span><br><span class="line"># define ZEND_OPCODE_HANDLER_ARGS zend_execute_data *execute_data</span><br></pre></td></tr></table></figure>

<p>修改<code>hook_eval.c</code>增加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int HOOK_INCLUDE_OR_EVAL(ZEND_OPCODE_HANDLER_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">	zend_execute_data *tmp = &amp;execute_data;</span><br><span class="line">	zend_op *opline = execute_data-&gt;opline;</span><br><span class="line">	return ZEND_USER_OPCODE_DISPATCH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接在<code>execute_data</code>中往下找调用的函数<code>system</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/228577/1557153079797-5582aae3-35f1-47f0-847d-7317e81ff6f2.png#align=left&display=inline&height=568&originHeight=568&originWidth=2878&size=0&status=done&width=2878" alt></p>
<p>这个也就是操作数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度，所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。</span><br></pre></td></tr></table></figure>

<p>编写<code>HOOK_INCLUDE_OR_EVAL</code>如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static int HOOK_INCLUDE_OR_EVAL(ZEND_OPCODE_HANDLER_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">	zend_op *opline = execute_data-&gt;opline;</span><br><span class="line">	zval *operands = opline-&gt;op1.zv;</span><br><span class="line">	char *cmd = Z_STRVAL_P(operands);</span><br><span class="line">	if(cmd)&#123;</span><br><span class="line">			if((strstr(cmd, &quot;system&quot;)==NULL)&amp;&amp;(strstr(cmd, &quot;exec&quot;)==NULL)&amp;&amp;(strstr(cmd, &quot;shell_exec&quot;)==NULL)&amp;&amp;(strstr(cmd, &quot;passthru&quot;)==NULL)&amp;&amp;(strstr(cmd, &quot;roc_open&quot;)==NULL))&#123;</span><br><span class="line">				return ZEND_USER_OPCODE_DISPATCH;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">			 return ZEND_USER_OPCODE_RETURN;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ZEND_USER_OPCODE_DISPATCH; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下执行流程</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/228577/1557153079566-e711a7e4-2981-44cb-ab38-21fd9eee72e2.png#align=left&display=inline&height=496&originHeight=496&originWidth=2878&size=0&status=done&width=2878" alt></p>
<p>当然,只hook掉<code>ZEND_INCLUDE_OR_EVAL</code>是很难防御的,比如说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">eval(&apos;echo `whoami`;&apos;);</span><br></pre></td></tr></table></figure>

<p>这种就必须再去hook <code>DO_FCALL</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/228577/1557153079577-f8d0e0e9-633f-479b-907b-9153a770eb8a.png#align=left&display=inline&height=1622&originHeight=1622&originWidth=2680&size=0&status=done&width=2680" alt></p>
<p>为了不影响业务并且去做更好的防御,还需要更深入的研究。</p>
<p>参考:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://drops.xmd5.com/static/drops/web-7333.html</span><br><span class="line">https://www.cnblogs.com/iamstudy/articles/php_code_rasp_1.html</span><br></pre></td></tr></table></figure>

<p>这篇我讲继续学习污点标记以及标记打在何处,学习过程我会通过阅读<code>http://pecl.php.net/package/taint</code>的源码来详述实现原理和一些细节。</p>
<p>下一篇讲会对污点跟踪进行分析。</p>
<h4 id="污点标记"><a href="#污点标记" class="headerlink" title="污点标记"></a>污点标记</h4><p>这里我们认为所有传入的数据都是不可信的,也就是说所有通过请求发送过来的数据都需要打上标记,被打上标记的数据是会传播的,比如说当进行字符串的拼接等操作在结束后要对新的数据从新标记,因为这个新的字符串仍然是不可信数据,但是经过一些处理函数,比如说<code>addslashes</code>这类函数,就可以将标记清除掉。</p>
<h5 id="标记点"><a href="#标记点" class="headerlink" title="标记点"></a>标记点</h5><p>首先我们需要知道怎么打标记,将标记打在何处</p>
<p>首先php7和php5的变量结构体是不一样的,因为结构体的不同,标记打在何处也就产生了区别</p>
<ul>
<li><p>php7</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _zend_value &#123;</span><br><span class="line">	zend_long         lval;				<span class="comment">/* long value */</span></span><br><span class="line">	<span class="keyword">double</span>            dval;				<span class="comment">/* double value */</span></span><br><span class="line">	zend_refcounted  *counted;</span><br><span class="line">	zend_string      *str;</span><br><span class="line">	zend_array       *arr;</span><br><span class="line">	zend_object      *obj;</span><br><span class="line">	zend_resource    *res;</span><br><span class="line">	zend_reference   *ref;</span><br><span class="line">	zend_ast_ref     *ast;</span><br><span class="line">	zval             *zv;</span><br><span class="line">	<span class="keyword">void</span>             *ptr;</span><br><span class="line">	zend_class_entry *ce;</span><br><span class="line">	zend_function    *func;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">uint32_t</span> w1;</span><br><span class="line">		<span class="keyword">uint32_t</span> w2;</span><br><span class="line">	&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_refcounted_h</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>         refcount;			<span class="comment">/* reference counter 32-bit */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			ZEND_ENDIAN_LOHI_3(</span><br><span class="line">				zend_uchar    type,</span><br><span class="line">				zend_uchar    flags,    <span class="comment">/* used for strings &amp; objects */</span></span><br><span class="line">				<span class="keyword">uint16_t</span>      gc_info)  <span class="comment">/* keeps GC root number (or 0) and color */</span></span><br><span class="line">		&#125; v;</span><br><span class="line">		<span class="keyword">uint32_t</span> type_info;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; zend_refcounted_h;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在taint中,对于php7来说污染标记的原理是利用<code>zend_uchar flags</code>变量回收结构中未被使用的标记为去做污染标记,如果随着版本的升级,这个位被使用后,那么就会产生冲突。</p>
</li>
<li><p>php5</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _zvalue_value &#123;</span><br><span class="line">	<span class="keyword">long</span> lval;					<span class="comment">/* long value */</span></span><br><span class="line">	<span class="keyword">double</span> dval;				<span class="comment">/* double value */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">char</span> *val;</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">	&#125; str;</span><br><span class="line">	HashTable *ht;				<span class="comment">/* hash table value */</span></span><br><span class="line">	zend_object_value obj;</span><br><span class="line">	zend_ast *ast;</span><br><span class="line">&#125; zvalue_value;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Variable information */</span></span><br><span class="line">	zvalue_value value;		<span class="comment">/* value */</span></span><br><span class="line">	zend_uint refcount__gc;</span><br><span class="line">	zend_uchar type;	<span class="comment">/* active type */</span></span><br><span class="line">	zend_uchar is_ref__gc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到这个版本的字段并不多,没有方便我们做标记的位置。<br>看下taint中是如何实现的吧。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z_STRVAL_PP(ppzval) = erealloc(Z_STRVAL_PP(ppzval), Z_STRLEN_PP(ppzval) + 1 + PHP_TAINT_MAGIC_LENGTH);</span><br><span class="line">PHP_TAINT_MARK(*ppzval, PHP_TAINT_MAGIC_POSSIBLE);</span><br></pre></td></tr></table></figure>

<p>看的宏的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define PHP_TAINT_MAGIC_NONE     0x00000000</span><br><span class="line">#define PHP_TAINT_MAGIC_POSSIBLE 0x6A8FCE84</span><br><span class="line">#define PHP_TAINT_MAGIC_UNTAINT  0x2C5E7F2D</span><br><span class="line"></span><br><span class="line">#define PHP_TAINT_MARK(zv, mark) *((unsigned *)(Z_STRVAL_P(zv) + Z_STRLEN_P(zv) + 1)) = (mark)</span><br><span class="line">#define PHP_TAINT_POSSIBLE(zv) (*(unsigned *)(Z_STRVAL_P(zv) + Z_STRLEN_P(zv) + 1) == PHP_TAINT_MAGIC_POSSIBLE)</span><br><span class="line">#define PHP_TAINT_UNTAINT(zv)  (*(unsigned *)(Z_STRVAL_P(zv) + Z_STRLEN_P(zv) + 1) == PHP_TAINT_MAGIC_UNTAINT)</span><br></pre></td></tr></table></figure>

<p>可能这样看不是很直观,直接看图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/228577/1557153113125-d2313878-e53c-455b-a82c-667b41d2ce6b.png#align=left&display=inline&height=1234&originHeight=1234&originWidth=2282&size=0&status=done&width=2282" alt></p>
<p>既然这样,那么当想要消除标记的时候直接再将</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PHP_TAINT_MAGIC_NONE     0x00000000</span><br></pre></td></tr></table></figure>

<p>打上即可。</p>
<h5 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h5><p>上面我们认为所有的请求都是不可信的,再没有经过安全函数时都要打上标记,接下来看下获取http请求参数以及给参数打上标记。</p>
<p>获取http请求参数,看鸟哥的文章<code>http://www.laruence.com/2008/04/04/17.html</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define TRACK_VARS_POST           0</span><br><span class="line">#define TRACK_VARS_GET            1</span><br><span class="line">#define TRACK_VARS_COOKIE         2</span><br><span class="line">#define TRACK_VARS_SERVER         3</span><br><span class="line">#define TRACK_VARS_ENV            4</span><br><span class="line">#define TRACK_VARS_FILES          5</span><br><span class="line">#define TRACK_VARS_REQUEST        6</span><br></pre></td></tr></table></figure>

<p>鸟哥问中提到<code>根据测试的结果，可以认定PG(http_globals)[TRACK_VARS_GET]是一个hash table;</code></p>
<p>我们先利用一下代码获取一下请求参数看一下,这里为了简单分析,直接修改上篇文章HOOK_INCLUDE_OR_EVAL来分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashTable *ht;</span><br><span class="line">	zval *arr;</span><br><span class="line">	arr = PG(http_globals)[TRACK_VARS_GET];</span><br><span class="line">	ht = HASH_OF(arr);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/228577/1557153113137-d266e5e5-cf6a-4e0f-9ece-9f861d69e788.png#align=left&display=inline&height=944&originHeight=944&originWidth=2862&size=0&status=done&width=2862" alt></p>
<p>可以看到是可以直接从这个hashtable里面获取到我们的参数的</p>
<p>可以利用相关的宏方便获取的,在zend_hash.h里面可以找到相关的宏</p>
<p>将hashtable中的数据全都遍历出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">HOOK_INCLUDE_OR_EVAL</span><span class="params">(ZEND_OPCODE_HANDLER_ARGS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ulong num_index;</span><br><span class="line">	<span class="keyword">char</span> *str_index;</span><br><span class="line">	zval **data;</span><br><span class="line">	HashTable *ht;</span><br><span class="line">	zval *arr;</span><br><span class="line">  <span class="keyword">char</span> *data;</span><br><span class="line">	<span class="keyword">char</span> *key;</span><br><span class="line">	arr = PG(http_globals)[TRACK_VARS_GET];</span><br><span class="line">	ht = HASH_OF(arr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (zend_hash_internal_pointer_reset(ht);</span><br><span class="line">			zend_hash_has_more_elements(ht) == SUCCESS;</span><br><span class="line">			zend_hash_move_forward(ht))</span><br><span class="line">	&#123;</span><br><span class="line">		zend_hash_get_current_key(ht, &amp;str_index, &amp;num_index, <span class="number">0</span>);</span><br><span class="line">		zend_hash_get_current_data(ht, (<span class="keyword">void</span>**)&amp;data);</span><br><span class="line">		key = Z_STRVAL_PP(data);</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> ZEND_USER_OPCODE_DISPATCH; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几个函数的作用其实命名已经很明确了,但是还是想看一下,拿<code>zend_hash_get_current_key</code>来说</p>
<p>我们打个断点<code>break zend_hash_get_current_key_ex</code></p>
<p>我们来看一下</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/228577/1557153113144-0d7921e9-8a8e-4502-8963-54c2fc9892ed.png#align=left&display=inline&height=1106&originHeight=1106&originWidth=2874&size=0&status=done&width=2874" alt></p>
<p>正如上面所说,跟命名是一样的,<code>str_index</code>将返回我们想要得到的key</p>
<p>将其打印出来</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/228577/1557153113153-fc179079-04a0-4db5-825f-865cf07ff90a.png#align=left&display=inline&height=336&originHeight=336&originWidth=920&size=0&status=done&width=920" alt></p>
<h5 id="打标记"><a href="#打标记" class="headerlink" title="打标记"></a>打标记</h5><p>我们重新创建一个扩展,完成基本定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_TAINT_MAGIC_LENGTH   sizeof(unsigned)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_TAINT_MAGIC_NONE     0x00000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_TAINT_MAGIC_POSSIBLE 0x6A8FCE84</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_TAINT_MAGIC_UNTAINT  0x2C5E7F2D</span></span><br><span class="line">PHP_FUNCTION(confirm_foobar_compiled);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_OPCODE_HANDLER_ARGS zend_execute_data *execute_data</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_TAINT_MARK(zv, mark) *((unsigned *)(Z_STRVAL_P(zv) + Z_STRLEN_P(zv) + 1)) = (mark)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_TAINT_POSSIBLE(zv) (*(unsigned *)(Z_STRVAL_P(zv) + Z_STRLEN_P(zv) + 1) == PHP_TAINT_MAGIC_POSSIBLE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_TAINT_UNTAINT(zv)  (*(unsigned *)(Z_STRVAL_P(zv) + Z_STRLEN_P(zv) + 1) == PHP_TAINT_MAGIC_UNTAINT)</span></span><br></pre></td></tr></table></figure>

<p>我们在请求初始化时,也就是<code>PHP_RINIT_FUNCTION</code>里面进行调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PHP_RINIT_FUNCTION(ptaint)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(PG(http_globals)[TRACK_VARS_GET] &amp;&amp; zend_hash_num_elements(Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_GET]))) &#123;</span><br><span class="line">		php_taint_mark_arr(PG(http_globals)[TRACK_VARS_GET] TSRMLS_CC);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后递归对数组进行标记</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">php_taint_mark_arr</span><span class="params">(zval *symbol_table TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	zval **data;</span><br><span class="line">	HashTable *ht = Z_ARRVAL_P(symbol_table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (zend_hash_internal_pointer_reset(ht);</span><br><span class="line">			zend_hash_has_more_elements(ht) == SUCCESS;</span><br><span class="line">			zend_hash_move_forward(ht))</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(zend_hash_get_current_data(ht, (<span class="keyword">void</span>**)&amp;data) == FAILURE)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(Z_TYPE_PP(data) == IS_ARRAY)</span><br><span class="line">		&#123;</span><br><span class="line">			php_taint_mark_arr(*data TSRMLS_CC);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(Z_TYPE_PP(data) == IS_STRING)&#123;</span><br><span class="line">			Z_STRVAL_PP(data) = erealloc(Z_STRVAL_PP(data), Z_STRLEN_PP(data) + <span class="number">1</span> + PHP_TAINT_MAGIC_LENGTH);</span><br><span class="line">			PHP_TAINT_MARK(*data, PHP_TAINT_MAGIC_POSSIBLE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下效果</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/228577/1557153113228-9d05e619-54a4-4d9d-ac9e-252dedd9c44b.png#align=left&display=inline&height=1618&originHeight=1618&originWidth=2548&size=0&status=done&width=2548" alt></p>
<p>参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www.laruence.com/2009/04/28/719.html</span><br><span class="line">https://www.jianshu.com/p/c6dea66c54f3</span><br><span class="line">https://www.cnblogs.com/iamstudy/articles/php_code_rasp_2.html</span><br></pre></td></tr></table></figure>

<p>上篇写的污点标记,这篇我会分析一下污点传播以及检测攻击点。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这里我暂且认为只要经过类似<code>mysql_real_escape_string</code>、<code>addslashes</code>、<code>htmlentities</code>这类函数,我们都将标记清除,但是如果经过类似<code>base64_decode</code>、<code>strtolower</code>或者字符串拼接这类经过传递仍然可能存在危害的函数,我们要进行标记传递。</p>
<p>这里有个问题,就是如果开始的时候进行了全局转义,就一定没有了危险嘛,如果某次请求又经过了类似 <code>stripslashes</code>这样的函数使引号逃逸出来呢,这里我觉得可以不进行污点清除,将其置为中间态,经过<code>stripslashes</code>的时候再恢复污点状态,这样可以减少一部分漏报。</p>
<p>然后思路是在一开始所有的请求变量都打上标记,在一些危险函数,如<code>eval</code>、<code>include</code>、<code>file_put_contents</code>、<code>unlink</code>这类函数时进行检测标记,如果仍然存在标记,我们认为它存在攻击点,因此做出警告。</p>
<h4 id="污点传播"><a href="#污点传播" class="headerlink" title="污点传播"></a>污点传播</h4><p>这里需要了解的知识点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作数类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_CONST    (1&lt;&lt;0)  <span class="comment">//1:字面量，编译时就可确定且不会改变的值，比如:$a = "hello~"，其中字符串"hello~"就是常量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_TMP_VAR  (1&lt;&lt;1)  <span class="comment">//2:临时变量，比如：$a = "hello~" . time()，其中"hello~" . time()的值类型就是IS_TMP_VAR</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_VAR      (1&lt;&lt;2)  <span class="comment">//4:PHP变量是没有显式的在PHP脚本中定义的，不是直接在代码通过$var_name定义的。这个类型最常见的例子是PHP函数的返回值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_UNUSED   (1&lt;&lt;3)  <span class="comment">//8:表示操作数没有用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_CV       (1&lt;&lt;4)  <span class="comment">//16:PHP脚本变量，即脚本里通过$var_name定义的变量，这些变量是编译阶段确定的</span></span></span><br></pre></td></tr></table></figure>

<p>以及opline里获取到参数，大致思路是，根据HOOK的OP指令的不同，获取op1或者op2，然后根据op1_type或者op2_type分情况抽取参数值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">（1）    IS_TMP_VAR</span><br><span class="line">如果op的类型为临时变量，则调用get_zval_ptr_tmp获取参数值。</span><br><span class="line">（2）    IS_VAR</span><br><span class="line">如果是变量类型，则直接从opline-&gt;var.ptr里获取</span><br><span class="line">（3）    IS_CV</span><br><span class="line">如果是编译变量参考ZEND_ECHO_SPEC_CV_HANDLER中的处理方式，是直接从EG(active_symbol_table)中寻找。</span><br><span class="line">（4）IS_CONST</span><br><span class="line">如果op类型是常量，则直接获取opline-&gt;op1.zv即可。</span><br><span class="line">上述方法都是从PHP源码中选取的，比如一个ZEND_ECHO指令的Handler会有多个，分别处理不同类型的op，这里有：</span><br><span class="line">ZEND_ECHO_SPEC_VAR_HANDLER</span><br><span class="line">ZEND_ECHO_SPEC_TMP_HANDLER</span><br><span class="line">ZEND_ECHO_SPEC_CV_HANDLER</span><br><span class="line">ZEND_ECHO_SPEC_CONST_HANDLER</span><br></pre></td></tr></table></figure>

<p>但是这里也有说的不对的地方,可能是版本的原因,比如说<code>opline-&gt;var.ptr</code>,我们直接这样是获取不到的,但是我们可以参考tmp的实现方式。</p>
<p>具体请看<code>zend_execute.c</code></p>
<p>我们来看下<code>get_zval_ptr_tmp</code>是如何实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> zend_always_inline zval *_get_zval_ptr_tmp(zend_uint var, <span class="keyword">const</span> zend_execute_data *execute_data, zend_free_op *should_free TSRMLS_DC)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> should_free-&gt;var = &amp;EX_T(var).tmp_var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个接口我们并不能直接调用,所以必须重新实现一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTAINT_T(offset) (*EX_TMP_VAR(execute_data, offset))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> zval *<span class="title">ptaint_get_zval_ptr_tmp</span><span class="params">(zend_uint var, <span class="keyword">const</span> zend_execute_data *execute_data, zend_free_op *should_free TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> should_free-&gt;var = &amp;PTAINT_T(var).tmp_var;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hook_include_or_eval</span><span class="params">(ZEND_OPCODE_HANDLER_ARGS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	zend_op *opline = execute_data-&gt;opline;</span><br><span class="line">	zval *op1 = <span class="literal">NULL</span>;</span><br><span class="line">	zend_free_op free_op1;</span><br><span class="line">	<span class="keyword">switch</span> (PTAINT_OP1_TYPE(opline))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> IS_TMP_VAR:</span><br><span class="line">			op1 = ptaint_get_zval_ptr_tmp(opline-&gt;op1.var, execute_data, &amp;free_op1 TSRMLS_CC);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ZEND_USER_OPCODE_DISPATCH; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下效果</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/228577/1557153153499-aecf8b20-d1e9-4f3d-81f0-542d50a57813.png#align=left&display=inline&height=778&originHeight=778&originWidth=2868&size=0&status=done&width=2868" alt></p>
<p>可以看到这样实现是可以的,那么我们完善代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> zval *<span class="title">ptaint_get_zval_ptr_tmp</span><span class="params">(zend_uint var, <span class="keyword">const</span> zend_execute_data *execute_data, zend_free_op *should_free TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> should_free-&gt;var = &amp;PTAINT_T(var).tmp_var;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> zval *<span class="title">ptaint_get_zval_ptr_var</span><span class="params">(zend_uint var, <span class="keyword">const</span> zend_execute_data *execute_data, zend_free_op *should_free TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	zval *ptr = PTAINT_T(var).var.ptr;</span><br><span class="line">	<span class="keyword">return</span> should_free-&gt;var = ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> zval **<span class="title">ptaint_get_zval_cv_lookup</span><span class="params">(zval ***ptr, zend_uint var, <span class="keyword">int</span> type TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	zend_compiled_variable *cv = &amp;CV_DEF_OF(var);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!EG(active_symbol_table) ||</span><br><span class="line">	    zend_hash_quick_find(EG(active_symbol_table), cv-&gt;name, cv-&gt;name_len+<span class="number">1</span>, cv-&gt;hash_value, (<span class="keyword">void</span> **)ptr)==FAILURE) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">			<span class="keyword">case</span> BP_VAR_R:</span><br><span class="line">			<span class="keyword">case</span> BP_VAR_UNSET:</span><br><span class="line">				zend_error(E_NOTICE, <span class="string">"Undefined variable: %s"</span>, cv-&gt;name);</span><br><span class="line">				<span class="comment">/* break missing intentionally */</span></span><br><span class="line">			<span class="keyword">case</span> BP_VAR_IS:</span><br><span class="line">				<span class="keyword">return</span> &amp;EG(uninitialized_zval_ptr);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> BP_VAR_RW:</span><br><span class="line">				zend_error(E_NOTICE, <span class="string">"Undefined variable: %s"</span>, cv-&gt;name);</span><br><span class="line">				<span class="comment">/* break missing intentionally */</span></span><br><span class="line">			<span class="keyword">case</span> BP_VAR_W:</span><br><span class="line">				Z_ADDREF(EG(uninitialized_zval));</span><br><span class="line">				<span class="keyword">if</span> (!EG(active_symbol_table)) &#123;</span><br><span class="line">					*ptr = (zval**)EX_CV_NUM(EG(current_execute_data), EG(active_op_array)-&gt;last_var + var);</span><br><span class="line">					**ptr = &amp;EG(uninitialized_zval);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					zend_hash_quick_update(EG(active_symbol_table), cv-&gt;name, cv-&gt;name_len+<span class="number">1</span>, cv-&gt;hash_value, &amp;EG(uninitialized_zval_ptr), <span class="keyword">sizeof</span>(zval *), (<span class="keyword">void</span> **)ptr);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> zval *<span class="title">ptaint_get_zval_ptr_cv</span><span class="params">(zend_uint var, <span class="keyword">int</span> type TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	zval ***ptr = EX_CV_NUM(EG(current_execute_data), var);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (UNEXPECTED(*ptr == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> *ptaint_get_zval_cv_lookup(ptr, var, type TSRMLS_CC);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> **ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hook_include_or_eval</span><span class="params">(ZEND_OPCODE_HANDLER_ARGS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	zend_op *opline = execute_data-&gt;opline;</span><br><span class="line">	zval *op1 = <span class="literal">NULL</span>;</span><br><span class="line">	zend_free_op free_op1;</span><br><span class="line">	<span class="keyword">switch</span> (PTAINT_OP1_TYPE(opline))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> IS_TMP_VAR:</span><br><span class="line">			op1 = ptaint_get_zval_ptr_tmp(PTAINT_OP1_GET_VAR(opline), execute_data, &amp;free_op1 TSRMLS_CC);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> IS_VAR:</span><br><span class="line">			op1 = ptaint_get_zval_ptr_var(PTAINT_OP1_GET_VAR(opline), execute_data, &amp;free_op1 TSRMLS_CC);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> IS_CONST:</span><br><span class="line">			op1 = PTAINT_OP1_GET_ZV(opline);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> IS_CV:</span><br><span class="line">			op1 = ptaint_get_zval_ptr_cv(PTAINT_OP1_GET_VAR(opline), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(op1 &amp;&amp; Z_TYPE_P(op1) == IS_STRING &amp;&amp; PHP_TAINT_POSSIBLE(op1))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (opline-&gt;extended_value == ZEND_EVAL)</span><br><span class="line">		&#123;</span><br><span class="line">				zend_error(E_WARNING, <span class="string">"(eval): Variables are not safely processed into the function"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				zend_error(E_WARNING, <span class="string">"(include or require): Variables are not safely processed into the function"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ZEND_USER_OPCODE_DISPATCH; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此,hook opcode来检测标记已经完成,但是有一部分函数需要来重新实现检测操作,下面来做解释,首先看一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_internal_function</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Common elements */</span></span><br><span class="line">	zend_uchar type;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * function_name;</span><br><span class="line">	zend_class_entry *scope;</span><br><span class="line">	zend_uint fn_flags;</span><br><span class="line">	<span class="keyword">union</span> _zend_function *prototype;</span><br><span class="line">	zend_uint num_args;</span><br><span class="line">	zend_uint required_num_args;</span><br><span class="line">	zend_arg_info *arg_info;</span><br><span class="line">	<span class="comment">/* END of common elements */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (*handler)(INTERNAL_FUNCTION_PARAMETERS);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">zend_module_entry</span> *<span class="title">module</span>;</span></span><br><span class="line">&#125; zend_internal_function;</span><br></pre></td></tr></table></figure>

<p>Hook内部函数其实和hook opcode的思路大体一致,通过修改handler的指向,指向我们实现的函数,在完成相应操作后继续调用原来的函数实现hook。</p>
<p>这里参考taint的实现,修改handler</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ptaint_override_func</span><span class="params">(<span class="keyword">char</span> *name, uint len, php_func handler, php_func *stash TSRMLS_DC)</span> <span class="comment">/* &#123;&#123;&#123; */</span> </span>&#123;</span><br><span class="line">	zend_function *func;</span><br><span class="line">	<span class="keyword">if</span> (zend_hash_find(CG(function_table), name, len, (<span class="keyword">void</span> **)&amp;func) == SUCCESS) &#123;</span><br><span class="line">		<span class="keyword">if</span> (stash) &#123;</span><br><span class="line">			*stash = func-&gt;internal_function.handler;</span><br><span class="line">		&#125;</span><br><span class="line">		func-&gt;internal_function.handler = handler;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下效果,handler的地址成功被修改</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/228577/1557153153501-33729b38-9c49-40e5-ae75-387b33f63ccd.png#align=left&display=inline&height=492&originHeight=492&originWidth=2872&size=0&status=done&width=2872" alt></p>
<p>但是如此的话是有问题的,在进行修改handler的时候需要考虑会不会覆盖掉原来的,因此这里定义了一个新的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ptaint_overridden_fucs</span> /* &#123;</span>&#123;&#123; */ &#123;</span><br><span class="line">	php_func strval;</span><br><span class="line">	php_func <span class="built_in">sprintf</span>;</span><br><span class="line">	php_func <span class="built_in">vsprintf</span>;</span><br><span class="line">	php_func explode;</span><br><span class="line">	php_func implode;</span><br><span class="line">	php_func trim;</span><br><span class="line">	php_func rtrim;</span><br><span class="line">	php_func ltrim;</span><br><span class="line">	php_func <span class="built_in">strstr</span>;</span><br><span class="line">	php_func str_pad;</span><br><span class="line">	php_func str_replace;</span><br><span class="line">	php_func substr;</span><br><span class="line">	php_func strtolower;</span><br><span class="line">	php_func strtoupper;</span><br><span class="line">&#125; ptaint_origin_funcs;</span><br></pre></td></tr></table></figure>

<p>在修改handler处</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stash) &#123;</span><br><span class="line">			*stash = func-&gt;internal_function.handler;</span><br><span class="line">		&#125;</span><br><span class="line">		func-&gt;internal_function.handler = handler;</span><br></pre></td></tr></table></figure>

<p>这里存储原函数的地址</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/228577/1557153153505-acb4804b-d875-48c7-a5f5-c94abced3394.png#align=left&display=inline&height=790&originHeight=790&originWidth=2546&size=0&status=done&width=2546" alt></p>
<p>然后将原来的handler修改为新函数,然后在新函数中利用上面的指针可以重新调用原来的处理函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(ptaint_strtoupper)</span><br><span class="line">&#123;</span><br><span class="line">	zval *str;</span><br><span class="line">	int tainted = 0;</span><br><span class="line">	php_func strtoupper;</span><br><span class="line">	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;z&quot;, &amp;str) == FAILURE) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if (IS_STRING == Z_TYPE_P(str) &amp;&amp; PHP_TAINT_POSSIBLE(str)) &#123;</span><br><span class="line">		tainted = 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PTAINT_O_FUNC(strtoupper)(INTERNAL_FUNCTION_PARAM_PASSTHRU);</span><br><span class="line">	</span><br><span class="line">	if (tainted &amp;&amp; IS_STRING == Z_TYPE_P(return_value) &amp;&amp; Z_STRLEN_P(return_value)) &#123;</span><br><span class="line">		Z_STRVAL_P(return_value) = erealloc(Z_STRVAL_P(return_value), Z_STRLEN_P(return_value) + 1 + PHP_TAINT_MAGIC_LENGTH);</span><br><span class="line">		PHP_TAINT_MARK(return_value, PHP_TAINT_MAGIC_POSSIBLE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在这重新调用原来函数执行,如果原来的字符串有标记的话将返回值也打上标记进行标记传递。</p>
<p>同样的原理,如果多个参数的情况,可以根据情况进行污点的检测,当然,如果想要做的更细的话,那就需要华更多的心思了。</p>
<p>文章到这里就结束了,感谢鸟哥的taint给了学习的机会,在后面一段时间我会去做完我想做的项目,如果有必要,我会把后续的记录整理后发出来,感谢。</p>
<p>参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://segmentfault.com/a/1190000014234234</span><br><span class="line">http://www.voidcn.com/article/p-gdecovzj-bpp.html</span><br><span class="line">https://paper.seebug.org/449/</span><br></pre></td></tr></table></figure>


      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">
      

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/web/">web</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/php拓展/">php拓展</a><a href="/tags/代码审计/">代码审计</a>
    </span>
    
    

    

    </div>

    
  </div>
</article>

  
	<section id="comment" class="comment">
		<div id="vcomments"></div>
	</section>
	<!-- LeanCloud -->
	<script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js"></script>
	<!-- Valine -->
	<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
	<script>
		new Valine({
			el: '#vcomments',
			appId: '86EMltAutxkr1IaqhOo0dP7l-gzGzoHsz',
			appKey: 'kdJzexN5shKVeTpQx49IQDaH'
		})
	</script>






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2020 kn0ck Team
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>